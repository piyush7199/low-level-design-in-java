# Low-Level Design in Java - Cursor Rules

## üéØ Project Overview
This is a comprehensive Low-Level Design (LLD) repository for Java developers and interview candidates. It contains design patterns, real-world system designs, and educational content focused on OOP principles, SOLID design, and software architecture best practices.

**Purpose:** Interview preparation, learning design patterns, and building scalable systems.

## üìÇ Project Structure

### Package Organization
```
org.lld/
‚îú‚îÄ‚îÄ patterns/          # Design pattern implementations
‚îÇ   ‚îú‚îÄ‚îÄ creational/    # Factory, Singleton, Builder, Prototype, Abstract Factory
‚îÇ   ‚îú‚îÄ‚îÄ structural/    # Adapter, Decorator, Flyweight
‚îÇ   ‚îî‚îÄ‚îÄ behavioural/   # Observer, Strategy, State, Command, Chain of Responsibility
‚îú‚îÄ‚îÄ practice/          # Real-world system design problems
‚îÇ   ‚îî‚îÄ‚îÄ design_*/      # Each system has naive_solution/ and improved_solution/
‚îî‚îÄ‚îÄ resources/docs/    # Educational documentation (OOP, SOLID, UML)
```

### Standard Directory Structure for Practice Problems
Each practice problem MUST follow this structure:
```
design_[system_name]/
‚îú‚îÄ‚îÄ README.md                    # Problem statement, requirements, design discussion
‚îú‚îÄ‚îÄ naive_solution/              # Simple implementation showing common pitfalls
‚îÇ   ‚îî‚îÄ‚îÄ *.java                   # Minimal classes, demonstrates anti-patterns
‚îî‚îÄ‚îÄ improved_solution/           # Production-ready implementation
    ‚îú‚îÄ‚îÄ models/                  # Domain entities (POJOs, enums, value objects)
    ‚îú‚îÄ‚îÄ services/                # Business logic layer
    ‚îú‚îÄ‚îÄ strategies/              # Strategy pattern implementations
    ‚îú‚îÄ‚îÄ states/                  # State pattern implementations (if applicable)
    ‚îú‚îÄ‚îÄ factories/               # Factory pattern implementations (if applicable)
    ‚îú‚îÄ‚îÄ repositories/            # Data access layer (if applicable)
    ‚îî‚îÄ‚îÄ Main.java               # Demo/example usage
```

## ‚òï Java Code Standards

### Java Version
- **Target:** Java 17+ (currently Java 21 in pom.xml)
- Use modern Java features: Records, Pattern Matching, Text Blocks where appropriate
- Avoid deprecated APIs

### Naming Conventions

#### Classes
- **PascalCase** for class names
- Use **nouns** for entity classes: `Vehicle`, `ParkingSpot`, `Order`
- Use descriptive suffixes:
  - `*Service` for business logic: `PaymentService`, `OrderService`
  - `*Strategy` for strategy implementations: `PricingStrategy`, `MatchingStrategy`
  - `*State` for state implementations: `IdleState`, `AuthenticatedState`
  - `*Factory` for factories: `VehicleFactory`, `PaymentFactory`
  - `*Repository` for data access: `UserRepository`, `BookRepository`
  - `*Manager` for coordinators: `ParkingSpotManager`
  - NO `*Impl`, `*Class`, `*Object` suffixes

#### Interfaces
- Use **adjectives** or **nouns**: `Comparable`, `Serializable`, `PaymentProcessor`
- Avoid `I` prefix (Hungarian notation): ‚ùå `IPayment` ‚úÖ `PaymentProcessor`

#### Methods
- **camelCase** for method names
- Use **verbs** or verb phrases: `calculateTotal()`, `processPayment()`, `findAvailableSpot()`
- Boolean methods start with `is`, `has`, `can`: `isAvailable()`, `hasPermission()`, `canProcess()`
- Collection getters: `getItems()` not `getItemList()`

#### Variables
- **camelCase** for variables
- Descriptive names: `customerName`, `totalOrderCount`, `isActiveUser`
- Avoid single-letter names except for loops: ‚ùå `n`, `d`, `c` ‚úÖ `name`, `distance`, `customer`
- Boolean variables: `isValid`, `hasAccess`, `canProceed`

#### Constants
- **UPPER_SNAKE_CASE** for constants
- Example: `MAX_CONNECTIONS`, `DEFAULT_CURRENCY`, `HOURLY_RATE`

#### Packages
- **lowercase** only: `org.lld.patterns.creational.singleton`
- Use full words, not abbreviations: `behavioural` not `beh`

### Class Organization Order
Every class MUST follow this order:
```java
public class ExampleClass {
    // 1. Constants (static final)
    private static final int MAX_RETRY = 3;
    
    // 2. Static variables
    private static ExampleClass instance;
    
    // 3. Instance variables (fields)
    private final String name;
    private final Repository repository;
    
    // 4. Constructors
    public ExampleClass(String name, Repository repository) {
        this.name = name;
        this.repository = repository;
    }
    
    // 5. Public methods
    public void doSomething() { }
    
    // 6. Protected methods
    protected void helperMethod() { }
    
    // 7. Private methods
    private void internalHelper() { }
    
    // 8. Getters and Setters
    public String getName() { return name; }
    
    // 9. Inner classes (if needed)
    private static class HelperClass { }
}
```

## üìã Practice Problems Reference

| # | System Design Problem | Key Patterns | Difficulty |
|---|----------------------|--------------|------------|
| 1 | Car Rental System | Strategy, State, Factory | Medium |
| 2 | Parking Lot System | Singleton, Strategy | Medium |
| 3 | Vending Machine | State, Strategy | Easy |
| 4 | Snake And Ladder | Factory, Strategy | Easy |
| 5 | Movie Ticket Booking System | Singleton, Factory, Strategy | Medium |
| 6 | Online Hotel Booking System | Strategy, Observer, Factory | Medium |
| 7 | ATM System | State, Strategy, Command, Singleton | Hard |
| 8 | Library Management System | Strategy, Observer, Repository | Medium |
| 9 | Elevator System | State, Strategy, Observer, Command | Hard |
| 10 | Food Delivery System | Strategy, State, Observer, Factory | Hard |
| 11 | Ride-Sharing System | Strategy, State, Observer, Factory, Singleton | Hard |
| 12 | **Queue Management System (Token)** | **Singleton, Strategy, Observer, State, Factory, Command** | **Medium** |

---

## üé® Design Pattern Standards

### When to Use Each Pattern

#### Creational Patterns
- **Singleton**: Single instance needed (ParkingLot, DatabaseConnection, BankingService)
- **Factory**: Object type determined at runtime (Vehicle types, Payment methods)
- **Builder**: Complex construction with many optional parameters (Car with options)
- **Prototype**: Expensive object creation, need cloning (Game templates)
- **Abstract Factory**: Families of related objects (UI components, Database drivers)

#### Structural Patterns
- **Adapter**: Interface incompatibility (Legacy system integration)
- **Decorator**: Dynamic behavior addition (Coffee with add-ons, Pizza toppings)
- **Flyweight**: Many similar objects, memory optimization (Game objects)

#### Behavioral Patterns
- **Strategy**: Algorithm varies at runtime (Pricing, Sorting, Matching)
- **Observer**: One-to-many notifications (Order updates, Event handling)
- **State**: Behavior changes with state (Order lifecycle, ATM states)
- **Command**: Encapsulate requests, support undo/redo (Transactions)
- **Chain of Responsibility**: Request handling chain (Approval workflows, Logging)

### Pattern Implementation Rules

#### Singleton Pattern
- Use **Bill Pugh Singleton** (static inner helper class) as default
- Thread-safe without synchronization overhead
- Private constructor MUST throw exception if instance already exists (prevent reflection attacks)
```java
public class ParkingLot {
    private ParkingLot() {
        if (instance != null) {
            throw new IllegalStateException("Instance already created");
        }
    }
    
    private static class SingletonHelper {
        private static final ParkingLot INSTANCE = new ParkingLot();
    }
    
    public static ParkingLot getInstance() {
        return SingletonHelper.INSTANCE;
    }
}
```

#### Strategy Pattern
- Always create an **interface** first
- One method per strategy interface (Interface Segregation Principle)
- Pass context/data as parameters, strategies should be stateless
```java
interface PricingStrategy {
    double calculateFee(Ticket ticket, LocalDateTime exitTime);
}
```

#### State Pattern
- State interface defines behavior, not just data
- State transitions handled by states themselves
- Context holds current state
```java
interface OrderState {
    void next(Order order);
    void prev(Order order);
    void printStatus();
}
```

#### Factory Pattern
- Use static factory methods for simple cases
- Separate Factory class for complex creation logic
- Return interface/abstract class, not concrete types

#### Observer Pattern
- Use `List<Observer>` for maintaining observers
- Provide `attach()`, `detach()`, `notifyObservers()` methods
- Observers should implement an interface

## üèóÔ∏è SOLID Principles (MANDATORY)

### Single Responsibility Principle (SRP)
- Each class has **ONE reason to change**
- Separate: Models, Services, Repositories, Strategies, States
- NO God classes - if a class has more than 5-7 public methods, consider splitting

### Open/Closed Principle (OCP)
- Open for extension, closed for modification
- Use interfaces and abstract classes
- Strategy pattern for varying algorithms
- Avoid switch statements on type - use polymorphism

### Liskov Substitution Principle (LSP)
- Subclasses must be substitutable for base classes
- Don't break parent class contracts
- Prefer composition over inheritance when behavior differs significantly

### Interface Segregation Principle (ISP)
- Many specific interfaces > one general interface
- Don't force classes to implement unused methods
- Example: `Workable`, `Eatable`, `Sleepable` instead of one `Worker` interface

### Dependency Inversion Principle (DIP)
- Depend on abstractions, not concretions
- Use constructor injection for dependencies
- Services depend on interfaces, not concrete implementations
```java
// ‚úÖ Good
public class PaymentService {
    private final PricingStrategy pricingStrategy;
    
    public PaymentService(PricingStrategy pricingStrategy) {
        this.pricingStrategy = pricingStrategy;
    }
}

// ‚ùå Bad
public class PaymentService {
    private HourlyPricing pricing = new HourlyPricing();
}
```

## üìù Documentation Standards

### README.md for Each Practice Problem
Every practice problem MUST have a README.md with:
1. **Problem Statement** - Clear description of what to build
2. **Requirements** - Functional and non-functional requirements
3. **Naive Solution** - Explanation of common pitfalls and design flaws
4. **Improved Solution** - Design discussion, patterns used, SOLID principles applied
5. **Key Learnings** - What makes the improved solution better

### README.md Template Structure
```markdown
# Design [System Name]

## 1. Problem Statement and Requirements
### Functional Requirements:
- Bullet points

### Non-Functional Requirements:
- Scalability, Reliability, Maintainability, etc.

## 2. Naive Solution: The "Starting Point"
### The Thought Process:
### Limitations and Design Flaws:
- Violation of SOLID principles
- Tight coupling issues
- Concurrency concerns

## 3. Improved Solution: The "Mentor's Guidance"
### Design Patterns Used:
### Core Classes and Interactions:

## 4. Final Design Overview
- Architecture summary
- Why this design is better
```

### Code Comments
- Use **JavaDoc** for public classes and methods
- Explain **WHY**, not WHAT (code should be self-documenting)
- Add comments for complex algorithms or non-obvious design decisions
- Document thread-safety considerations
```java
/**
 * Service for managing user-related operations.
 * 
 * This service handles user registration, authentication,
 * and profile management. All methods in this class are
 * thread-safe.
 * 
 * @author [Your Name]
 * @version 1.0
 * @since 2024-01-01
 */
public class UserService {
    /**
     * Calculates the total price including tax and discounts.
     * 
     * @param items List of items (must not be null or empty)
     * @param taxRate Tax rate as decimal (e.g., 0.08 for 8%)
     * @param discountCode Optional discount code (can be null)
     * @return Total price after tax and discounts
     * @throws IllegalArgumentException if items is null or empty
     * @throws InvalidDiscountException if discount code is invalid
     */
    public double calculateTotal(List<Item> items, double taxRate, String discountCode) {
        // implementation
    }
}
```

### Pattern README.md
Each pattern directory should have:
- **Definition** and intent
- **Intuition** - Why this pattern exists
- **Use Cases** - When to apply
- **Code Example** - Complete working example
- **UML Diagram** - Visual representation
- **Pros & Cons** - Trade-offs
- **Further Reading** - External resources

## üéØ Code Quality Standards

### Error Handling
- Use **specific exceptions**, not generic `Exception`
- Create custom exceptions for domain-specific errors
- Fail fast - validate inputs at method entry
- Use `Optional<T>` for methods that might return null
```java
// ‚úÖ Good
public Optional<ParkingSpot> findAvailableSpot(VehicleType type) {
    Objects.requireNonNull(type, "Vehicle type cannot be null");
    // ... logic
    return Optional.ofNullable(spot);
}

// ‚ùå Bad
public ParkingSpot findAvailableSpot(VehicleType type) throws Exception {
    return null; // Might return null
}
```

### Immutability
- Use `final` for fields that don't change
- Use `final` for method parameters
- Consider using records for simple data classes (Java 17+)
- Make defensive copies of mutable objects
```java
// ‚úÖ Good - Immutable
public class Ticket {
    private final String ticketId;
    private final String vehiclePlate;
    private final LocalDateTime entryTime;
    
    public Ticket(String ticketId, String vehiclePlate) {
        this.ticketId = ticketId;
        this.vehiclePlate = vehiclePlate;
        this.entryTime = LocalDateTime.now();
    }
    
    // Only getters, no setters
}
```

### Null Safety
- Use `Objects.requireNonNull()` for null checks
- Return `Optional<T>` instead of null
- Use `@NonNull` annotations where available
- Initialize collections to empty, not null: `new ArrayList<>()` not `null`

### Enum Usage
- Use enums for fixed set of constants: `VehicleType`, `OrderStatus`, `SpotSize`
- Add behavior to enums when appropriate
```java
public enum VehicleType {
    MOTORCYCLE(SpotSize.SMALL),
    CAR(SpotSize.MEDIUM),
    BUS(SpotSize.LARGE);
    
    private final SpotSize requiredSpotSize;
    
    VehicleType(SpotSize requiredSpotSize) {
        this.requiredSpotSize = requiredSpotSize;
    }
    
    public SpotSize getRequiredSpotSize() {
        return requiredSpotSize;
    }
}
```

### Method Design
- Keep methods **short** (< 20 lines ideally, max 50 lines)
- One level of abstraction per method
- Max 3-4 parameters (use builder or parameter object for more)
- Return early to reduce nesting
```java
// ‚úÖ Good - Early return
public void processOrder(Order order) {
    if (order == null) return;
    if (!order.isValid()) return;
    // ... process
}

// ‚ùå Bad - Deep nesting
public void processOrder(Order order) {
    if (order != null) {
        if (order.isValid()) {
            // ... deep nesting
        }
    }
}
```

## üß™ Testing Considerations
- Each class should be testable in isolation
- Use dependency injection for easier mocking
- Avoid static methods (except factory methods)
- Design for testability: separate concerns, small methods

## üö´ Anti-Patterns to Avoid

### God Classes
‚ùå One class doing everything - violates SRP
```java
// ‚ùå BAD
class ParkingLot {
    void findSpot() { }
    void calculateFee() { }
    void processPayment() { }
    void sendEmail() { }
    void generateReport() { }
    // 50 more methods...
}
```

### Magic Numbers/Strings
‚ùå Use constants or enums
```java
// ‚ùå BAD
if (status == 5) { }
if (type.equals("premium")) { }

// ‚úÖ GOOD
if (status == OrderStatus.DELIVERED) { }
if (type == CustomerType.PREMIUM) { }
```

### Tight Coupling
‚ùå Direct dependencies on concrete classes
```java
// ‚ùå BAD
class OrderService {
    private MySQLDatabase db = new MySQLDatabase();
}

// ‚úÖ GOOD
class OrderService {
    private final Database database;
    public OrderService(Database database) {
        this.database = database;
    }
}
```

### Premature Optimization
‚ùå Don't over-engineer before needed
- Start simple, add complexity only when required
- Don't use 10 patterns for a simple problem
- Optimize based on actual performance issues, not assumptions

## üé´ Practice Problem: Online Queue Management (Token System)

### Problem Overview
Design a Token-based Queue Management System for banks, hospitals, government offices, or service centers where customers take tokens and wait for their turn.

### Functional Requirements
- **Token Generation**: Generate unique tokens for customers with optional priority levels
- **Multiple Counters/Service Points**: Support multiple service counters serving different token types
- **Queue Management**: FIFO processing with priority queue support (VIP, Senior Citizen, Regular)
- **Status Tracking**: Track token status (Waiting, Being Served, Completed, Cancelled, No-Show)
- **Counter Assignment**: Assign tokens to available counters based on service type
- **Notifications**: Notify customers when their turn is approaching
- **Display Board**: Show current token being served at each counter
- **Analytics**: Track average wait time, service time, tokens processed

### Non-Functional Requirements
- Handle high concurrency (multiple tokens generated simultaneously)
- Real-time updates for display boards
- Scalable for multiple branches/locations

### Suggested Directory Structure
```
design_queue_management_system/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ naive_solution/
‚îÇ   ‚îî‚îÄ‚îÄ QueueSystem.java          # God class anti-pattern
‚îî‚îÄ‚îÄ improved_solution/
    ‚îú‚îÄ‚îÄ models/
    ‚îÇ   ‚îú‚îÄ‚îÄ Token.java            # Token entity with status
    ‚îÇ   ‚îú‚îÄ‚îÄ TokenStatus.java      # Enum: WAITING, SERVING, COMPLETED, CANCELLED, NO_SHOW
    ‚îÇ   ‚îú‚îÄ‚îÄ TokenType.java        # Enum: REGULAR, PRIORITY, VIP, SENIOR_CITIZEN
    ‚îÇ   ‚îú‚îÄ‚îÄ Counter.java          # Service counter entity
    ‚îÇ   ‚îú‚îÄ‚îÄ CounterStatus.java    # Enum: AVAILABLE, BUSY, CLOSED
    ‚îÇ   ‚îî‚îÄ‚îÄ Customer.java         # Customer details
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îú‚îÄ‚îÄ TokenService.java     # Token generation and management
    ‚îÇ   ‚îú‚îÄ‚îÄ QueueService.java     # Queue operations
    ‚îÇ   ‚îú‚îÄ‚îÄ CounterService.java   # Counter management
    ‚îÇ   ‚îî‚îÄ‚îÄ NotificationService.java
    ‚îú‚îÄ‚îÄ strategies/
    ‚îÇ   ‚îú‚îÄ‚îÄ TokenAssignmentStrategy.java      # Interface
    ‚îÇ   ‚îú‚îÄ‚îÄ FIFOAssignmentStrategy.java       # First-in-first-out
    ‚îÇ   ‚îú‚îÄ‚îÄ PriorityAssignmentStrategy.java   # Priority-based
    ‚îÇ   ‚îî‚îÄ‚îÄ RoundRobinCounterStrategy.java    # Counter selection
    ‚îú‚îÄ‚îÄ observers/
    ‚îÇ   ‚îú‚îÄ‚îÄ QueueObserver.java               # Interface
    ‚îÇ   ‚îú‚îÄ‚îÄ DisplayBoardObserver.java        # Updates display
    ‚îÇ   ‚îú‚îÄ‚îÄ CustomerNotificationObserver.java # SMS/App notification
    ‚îÇ   ‚îî‚îÄ‚îÄ AnalyticsObserver.java           # Collects metrics
    ‚îú‚îÄ‚îÄ states/
    ‚îÇ   ‚îú‚îÄ‚îÄ TokenState.java       # Interface
    ‚îÇ   ‚îú‚îÄ‚îÄ WaitingState.java
    ‚îÇ   ‚îú‚îÄ‚îÄ ServingState.java
    ‚îÇ   ‚îú‚îÄ‚îÄ CompletedState.java
    ‚îÇ   ‚îî‚îÄ‚îÄ CancelledState.java
    ‚îú‚îÄ‚îÄ QueueManagementSystem.java  # Singleton - main entry point
    ‚îî‚îÄ‚îÄ Main.java
```

### Key Design Patterns
| Pattern | Usage |
|---------|-------|
| **Singleton** | `QueueManagementSystem` - single system instance |
| **Strategy** | Token assignment algorithms, counter selection |
| **Observer** | Display board updates, customer notifications |
| **State** | Token lifecycle (Waiting ‚Üí Serving ‚Üí Completed) |
| **Factory** | Token creation based on customer type |
| **Command** | Token operations (call next, skip, recall) |

### Core Interfaces
```java
// Strategy for assigning tokens to counters
interface TokenAssignmentStrategy {
    Optional<Token> getNextToken(List<Token> waitingTokens);
}

// Observer for queue changes
interface QueueObserver {
    void onTokenCalled(Token token, Counter counter);
    void onTokenCompleted(Token token);
    void onQueueUpdated(List<Token> waitingTokens);
}

// State pattern for token lifecycle
interface TokenState {
    void callToken(Token token, Counter counter);
    void completeService(Token token);
    void cancelToken(Token token);
    void markNoShow(Token token);
}
```

### Key Classes
```java
public class Token {
    private final String tokenNumber;      // e.g., "A-001", "P-015"
    private final TokenType type;
    private final Customer customer;
    private final LocalDateTime createdAt;
    private TokenState state;
    private Counter assignedCounter;
    private LocalDateTime servedAt;
    private LocalDateTime completedAt;
}

public class Counter {
    private final String counterId;
    private final List<TokenType> servesTypes;  // Types this counter handles
    private CounterStatus status;
    private Token currentToken;
    private String operatorName;
}
```

### Interview Discussion Points
1. **Concurrency**: How to handle race conditions when multiple counters try to pick the same token?
2. **Fairness**: How to ensure priority tokens don't starve regular tokens?
3. **Scalability**: How to extend for multiple branches with centralized reporting?
4. **Real-time Updates**: WebSocket vs polling for display boards?
5. **Recovery**: What happens if system crashes mid-service?

---

## üéì Interview-Ready Code Standards

### Code Should Demonstrate
1. **Clear thinking** - Well-organized, logical flow
2. **Design patterns** - Appropriate pattern usage (not forced)
3. **SOLID principles** - Especially SRP and OCP
4. **Extensibility** - Easy to add new features
5. **Error handling** - Edge cases considered
6. **Clean code** - Readable, maintainable

### Main.java Demo Files
- Show **realistic usage scenarios**
- Demonstrate **multiple features**
- Include **edge cases**
- Print clear output showing system behavior
```java
public class Main {
    public static void main(String[] args) {
        System.out.println("=== Parking Lot System Demo ===\n");
        
        // Initialize system
        ParkingLot parkingLot = ParkingLot.getInstance(...);
        
        // Demonstrate feature 1
        System.out.println("1. Vehicle Entry:");
        // ... code
        
        // Demonstrate feature 2
        System.out.println("\n2. Vehicle Exit:");
        // ... code
    }
}
```

## üìä UML Diagrams
- Store in `src/main/java/org/lld/diagrams/` directory
- Use PNG or SVG format
- Name format: `pattern-name-uml.png`
- Reference in README.md files

## üîÑ Version Control
- Commit messages should be clear and descriptive
- Group related changes together
- Don't commit commented-out code
- Don't commit IDE-specific files (already in .gitignore)

## üì¶ Maven Standards
- Java compiler source/target: 17+
- UTF-8 encoding
- Keep dependencies minimal (this is educational code)
- No unnecessary plugins

## üéØ Key Principles Summary

**Remember:**
1. **Clarity over cleverness** - Code should be easy to understand
2. **SOLID principles** - Apply them consistently
3. **Design patterns** - Use when they solve a problem, not just because they exist
4. **Extensibility** - Design for future changes
5. **Separation of concerns** - Each class has one job
6. **Interview focus** - Code should demonstrate your design thinking

**Good design is not about following rules blindly, but understanding trade-offs and making informed decisions!**

---

*These rules are designed to maintain consistency across the repository and ensure all code is production-ready and interview-appropriate.*

